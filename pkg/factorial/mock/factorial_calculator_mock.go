// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/Yscream/go-factorial"
	"sync"
)

// Ensure, that FactorialCalculatorMock does implement entities.FactorialCalculator.
// If this is not the case, regenerate this file with moq.
var _ entities.FactorialCalculator = &FactorialCalculatorMock{}

// FactorialCalculatorMock is a mock implementation of entities.FactorialCalculator.
//
//	func TestSomethingThatUsesFactorialCalculator(t *testing.T) {
//
//		// make and configure a mocked entities.FactorialCalculator
//		mockedFactorialCalculator := &FactorialCalculatorMock{
//			CalculateFunc: func(n int) int {
//				panic("mock out the Calculate method")
//			},
//			CalculateConcurrentlyFunc: func(inputNumbers *entities.Numbers) *entities.Numbers {
//				panic("mock out the CalculateConcurrently method")
//			},
//		}
//
//		// use mockedFactorialCalculator in code that requires entities.FactorialCalculator
//		// and then make assertions.
//
//	}
type FactorialCalculatorMock struct {
	// CalculateFunc mocks the Calculate method.
	CalculateFunc func(n int) int

	// CalculateConcurrentlyFunc mocks the CalculateConcurrently method.
	CalculateConcurrentlyFunc func(inputNumbers *entities.Numbers) *entities.Numbers

	// calls tracks calls to the methods.
	calls struct {
		// Calculate holds details about calls to the Calculate method.
		Calculate []struct {
			// N is the n argument value.
			N int
		}
		// CalculateConcurrently holds details about calls to the CalculateConcurrently method.
		CalculateConcurrently []struct {
			// InputNumbers is the inputNumbers argument value.
			InputNumbers *entities.Numbers
		}
	}
	lockCalculate             sync.RWMutex
	lockCalculateConcurrently sync.RWMutex
}

// Calculate calls CalculateFunc.
func (mock *FactorialCalculatorMock) Calculate(n int) int {
	if mock.CalculateFunc == nil {
		panic("FactorialCalculatorMock.CalculateFunc: method is nil but FactorialCalculator.Calculate was just called")
	}
	callInfo := struct {
		N int
	}{
		N: n,
	}
	mock.lockCalculate.Lock()
	mock.calls.Calculate = append(mock.calls.Calculate, callInfo)
	mock.lockCalculate.Unlock()
	return mock.CalculateFunc(n)
}

// CalculateCalls gets all the calls that were made to Calculate.
// Check the length with:
//
//	len(mockedFactorialCalculator.CalculateCalls())
func (mock *FactorialCalculatorMock) CalculateCalls() []struct {
	N int
} {
	var calls []struct {
		N int
	}
	mock.lockCalculate.RLock()
	calls = mock.calls.Calculate
	mock.lockCalculate.RUnlock()
	return calls
}

// CalculateConcurrently calls CalculateConcurrentlyFunc.
func (mock *FactorialCalculatorMock) CalculateConcurrently(inputNumbers *entities.Numbers) *entities.Numbers {
	if mock.CalculateConcurrentlyFunc == nil {
		panic("FactorialCalculatorMock.CalculateConcurrentlyFunc: method is nil but FactorialCalculator.CalculateConcurrently was just called")
	}
	callInfo := struct {
		InputNumbers *entities.Numbers
	}{
		InputNumbers: inputNumbers,
	}
	mock.lockCalculateConcurrently.Lock()
	mock.calls.CalculateConcurrently = append(mock.calls.CalculateConcurrently, callInfo)
	mock.lockCalculateConcurrently.Unlock()
	return mock.CalculateConcurrentlyFunc(inputNumbers)
}

// CalculateConcurrentlyCalls gets all the calls that were made to CalculateConcurrently.
// Check the length with:
//
//	len(mockedFactorialCalculator.CalculateConcurrentlyCalls())
func (mock *FactorialCalculatorMock) CalculateConcurrentlyCalls() []struct {
	InputNumbers *entities.Numbers
} {
	var calls []struct {
		InputNumbers *entities.Numbers
	}
	mock.lockCalculateConcurrently.RLock()
	calls = mock.calls.CalculateConcurrently
	mock.lockCalculateConcurrently.RUnlock()
	return calls
}
